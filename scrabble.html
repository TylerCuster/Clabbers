<html>
<body>
<script src="jquery-1.9.1.js"></script>
<script type="text/javascript">
/*

Clean up unneeded functions

Place Board using JQUERY?
Place Hand using JQUERY?

Play- part of a Turn. click and place tiles on to board as part of the Play. when user clicks "play word" button, check isValidWord and isInline. if not valid word or not in a line and adjacent, then return the letters submitted to the hand, keeping the letters that were already on the board. if valid word, mark the letters in Play as a permanent part of the board.

How do we access the empty Square objects we create when we create a Board? How do we define multiple variables within a loop? eval? Should we even use a Square object or just add the traits we need to the array?

isValidWord (string is in word dictionary)

Turn/Submit Word

Update score information

Board different special bonus positions

effects
images
*/
$(document).ready(function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 10;
var BOARD_WIDTH = 10;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, " ": 0}

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, " ": 2}

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

// Takes word as dictionary object
function calculateWordScore(word) {
	score = 0;
	forEachIn(word, function(letter, count) {
		score += LETTER_VALUES[letter] * count;
	});
	return score;
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
};

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
};

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
};

function registerEventHandler(node, event, handler) {
  if (typeof node.addEventListener == "function")
    node.addEventListener(event, handler, false);
  else
    node.attachEvent("on" + event, handler);
};

function addHandler(node, type, handler) {
  function wrapHandler(event) {
    handler(window.event);
  }
  registerEventHandler(node, type, wrapHandler);
  return {node: node, type: type, handler: wrapHandler};
}

function removeHandler(object) {
  unregisterEventHandler(object.node, object.type, object.handler);
}

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
};

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var Hand = Dictionary.extend({
	construct: function(bag, startValues) {
		this.bag = bag;
		this.values = startValues || {};
		if (startValues == null)
			this.initialHand();
		copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", {"id": String(i)}, "x");
				else
					var tableCell = dom("TD", {"id": String(i)}, copy[i]);
				}
			tableRow.appendChild(tableCell);
		};
		
		this.table = dom("TABLE", {"id": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
		newLetter = this.bag.selectRandomLetter();
		this.add(newLetter);
		this.bag.remove(newLetter);
	},
	initialHand: function() {
		for (var i = 0; i < HAND_SIZE; i++) {
			this.grabLetter(this.bag);
		};
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	add: function(letter) {
		if (this.contains(letter) == false) 
			this.store(letter, 1);
		else
			this.store(letter, this.lookup(letter)+1);
	},
	clear: function() {
		this.values = {};
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
});
	
var Square = {
	construct: function(x, y) {
		this.x = x;
		this.y = y;
		this.letter = "x";
		this.lock = false;
	},
	isEmpty: function() {
		return this.letter == "x";
	},
	setLock: function() {
		this.lock = true;
	},
	getLock: function() {
		return this.lock;
	},
	setLetter: function(letter) {
		this.letter = letter;
	},
	getLetter: function() {
		return this.letter;
	}
};	
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;
		var lock = true;

		this.board = [];
		var tbody = dom("TBODY");
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableSquare = dom("TD", {"id": String(x) + String(y)}, "x");
				tableRow.appendChild(tableSquare);
				// row.push(Square.create(x, y));
				row.push([lock, null]);
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		
		this.table = dom("TABLE", {"id": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			throw "Space not on game board: " + error.message;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.isEmpty(x, y)) {
			this.board[y][x][1] = letter;
			$('#' + String(x) + String(y)).text(letter);
			this.setLock(x, y, false);
		}
	},
	removeLetter: function(x, y) {
		this.board[y][x][1] = null;
	},
	// Sets lock to boolean 'value'. 'true' if one can't move the space, such as in an empty space or a letter that has already been played. 'false' if one can move the letter such as in rearranging letters for a play
	setLock: function(x, y, value) {
		this.board[y][x][0] = value;
	},
	getLock: function(x, y) {
		return this.board[y][x][0];
	},
	// Takes array of arrays in the form [x, y]. Are they all in a single row or column? Are all the values adjacent to each other? If so, returns true.
	isInline: function(play) {
		var xValue = play[0][0];
		var yValue = play[0][1];
		if (play[0][0] == play[1][0])
			var row = true;
		else if (play[0][1] = play[1][1])
			var column = true;
		else
			return false;
		for (var i = 1; i < play.length; i++) {
			if (row) {
				// Checks if value is in the same row and if the y value is adjacent to the previous y value
				if ((play[i][0] != xValue) || (play[i][1] != (play[i-1][1] + 1)))
					return false;
			}
			if (column) {
				if ((play[i][1] != yValue) || (play[i][0] != (play[i-1][0] + 1)))
					return false;
			}
		};
		return true;
	},
	// Scans board for letters with a lock of false to determine the play
	findPlay: function() {
		for (var y = 0; y < this.height; y++) {
			for (var x = 0; x < this.width; x++) {	
				if (this.board[y][x][0] == false)
					play.append([x, y]);
			}
		}
	},
	// Takes array of arrays in the form [x, y, letter]. Return string from letters placed on board.
	boardToWord: function(play) {
		word = "";
		for (var i = 0; i < play.length; i++) {
			word += play[i][2];
		}
		return word;
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var lock = this.board[i][j][0];
				func(lock, this.valueAt(j, i));
			}
		}
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
};

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		this.place = place;
		this.score = 0;
		
		$('<button id="newGame">New game</button>').appendTo(this.place);
		$('#newGame').on('click', function() {
			location.reload();
			});
		$('<button id="newHand">New hand</button>').appendTo(this.place);
		$('#newHand').on('click', method(this, 'newHand'));
		$('<button id="deselect">Deselect letter</button>').appendTo(this.place);

		$('<div id="score">Score: ' + this.score + '</div>').appendTo(this.place);
		$('<div id="messages">&nbsp;</div>').appendTo(this.place);
		
		this.initial();
		
		var letterEvent = null;
		var self = this;
		
		//Hand click handlers
		$('#hand').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				// Placing a letter back in hand
				if (letterEvent) {
					$('#' + $this.attr('id')).text(letterEvent[0]);
					self.hand.add(letterEvent[0]);
					letterEvent = null;
				}
				// Grabbing letter from hand
				else {
					console.log("clicked on hand: " + $this.text());
					letterEvent = [$this.text(), $this.attr("id")];
					self.hand.remove($this.text());
					$this.text("x");
				}
			});
		});
		
		//Board click handlers
		$('#board').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				var square = $this.attr("id");
				console.log("clicked board at: " + square);
				// Place letter on board
				if ((letterEvent) && (self.board.isEmpty(square[0], square[1]))) {
					self.placeLetterFromHand(square[0], square[1], letterEvent[0]);
					letterEvent = null;
				}
				// Grab letter from board
				else if ((!letterEvent) && (self.board.getLock(square[0], square[1]) == false)) {
					console.log("grabbed square with value: " + $this.text());
					letterEvent = [$this.text(), $this.attr("id")];
					$this.text("x");
					self.board.removeLetter(square[0], square[1]);
					self.board.setLock(square[0], square[1], true);
				}
				// Recall letter to previous position if player tries to place letter in bad position
				else if ((letterEvent) && !self.board.isEmpty(square[0], square[1])) {
					self.recallLetter(letterEvent);
					letterEvent = null;
				}				
			});
		});
		
		// Returns letter from whence it came
		$('#deselect').on('click', function() {
			if (letterEvent) {
				console.log("deselect");
				self.recallLetter(letterEvent);
				letterEvent = null;
			}
		});
	},
	initial: function() {
		if (this.board && this.hand) {
			this.board.removeFromPage(this.place);
			this.hand.removeFromPage(this.place);
		}
		this.score = 0;
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.board.placeToPage(this.place);
		this.bag = Bag.create();
		this.hand = Hand.create(this.bag, null);
		this.hand.placeToPage(this.place);
	},
	newHand: function() {
		if (this.board && this.hand && (this.bag.count() >= HAND_SIZE)) {
			this.hand.clear();
			this.hand.removeFromPage(this.place);
			this.hand = Hand.create(this.bag, null);
			this.hand.placeToPage(this.place);
		}
		else
			$('#messages').text("Bag out of letters");
	},
	recallLetter: function(letterEvent) {
			$('#' + letterEvent[1]).text(letterEvent[0]);
			letterEvent = null;
	},
	placeLetterFromHand: function(x, y, letter) {
		//Wait until Play is finished to remove from hand
		//this.hand.remove(letter);
		this.board.placeLetter(x, y, letter);
		console.log("Placed on board: " + letter);
	},
	updateScore: function(newPoints) {
		this.score += newPoints;
	}
};

function boardToWordTests() {
	testBoard = Board.create(6, 6);
	return testBoard.boardToWord([[1, 2, "D"], [1, 3, "O"], [1, 2, "G"]]) == "DOG" &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) == "UP" &&
		testBoard.boardToWord([[1, 4, "Y"], [2, 4, "O"], [3, 4, "U"]]) == "YOU" &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) == testBoard.boardToWord([[1, 3, "U"], [1, 2, "P"]]) &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) != "PU";
}
function isInlineTests() {
	var testBoard = Board.create(5, 5);
	return (testBoard.isInline([[1,2], [1,3], [1, 4]]) == true) &&
			(testBoard.isInline([[0, 2], [1, 2], [2, 2]]) == true) &&
			(testBoard.isInline([[0, 3], [0, 4], [0, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 2]]) == false) &&
			(testBoard.isInline([[0, 1], [0, 2], [0, 3], [0, 0]]) == false);
}
function isValidHandTests(testBag) {
	var testHand = Hand.create(testBag, {"B": 1, "A": 2, "Y": 1});
	return testHand.isValidHand("BABY") == false &&
		testHand.isValidHand("BAY") ==  true &&
		testHand.isValidHand("BY") == true &&
		testHand.isValidHand("XBY") == false &&
		testHand.isValidHand("BAAY") == true;
}

var testBag = Bag.create();
console.log("isInline tests: " + isInlineTests());
console.log("isValidHand tests: " + isValidHandTests(testBag));
console.log("boardToWord tests: " + boardToWordTests());

var scrabble = Game.create(document.body);

});
</script>
</body>
</html>