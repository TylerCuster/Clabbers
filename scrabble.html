<html>
<script type="text/javascript">
/*
isValidWord (string is in word dictionary)
Game click handlers for placing letters

Play- part of a Turn. click and place tiles on to board as part of the Play. when user clicks "play word" button, check isValidWord and isInline. if not valid word or not in a line and adjacent, then return the letters submitted to the hand, keeping the letters that were already on the board. if valid word, mark the letters in Play as a permanent part of the board.

How do we access the empty squares we create when we create a Board? How do we define many variables within a loop?

re-write dom elements using JQUERY
Place buttons
Place score information
Place messages/warnings
Place Board
Place Hand

Board different special bonus positions
Turn
Player

images
*/

window.onload = function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 10;
var BOARD_WIDTH = 10;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, " ": 0}

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, " ": 2}

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

// Takes word as dictionary object
function calculateWordScore(word) {
	score = 0;
	forEachIn(word, function(letter, count) {
		score += LETTER_VALUES[letter] * count;
	});
	return score;
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
};

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
};

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
};

function registerEventHandler(node, event, handler) {
  if (typeof node.addEventListener == "function")
    node.addEventListener(event, handler, false);
  else
    node.attachEvent("on" + event, handler);
};

function addHandler(node, type, handler) {
  function wrapHandler(event) {
    handler(window.event);
  }
  registerEventHandler(node, type, wrapHandler);
  return {node: node, type: type, handler: wrapHandler};
}

function removeHandler(object) {
  unregisterEventHandler(object.node, object.type, object.handler);
}

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
};

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var Square = {
	construct: function(x, y) {
		this.x = x;
		this.y = y;
		this.letter = "x";
		this.lock = false;
	},
	isEmpty: function() {
		return this.letter == "x";
	},
	setLock: function() {
		this.lock = true;
	},
	getLock: function() {
		return this.lock;
	},
	setLetter: function(letter) {
		this.letter = letter;
	},
	getLetter: function() {
		return this.letter;
	}
};

var Hand = Dictionary.extend({
	construct: function(bag, startValues) {
		this.bag = bag;
		this.values = startValues || {};
		if (startValues == null)
			this.initialHand();
		copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", null, "x");
				else
					var tableCell = dom("TD", null, copy[i]);
				}
			else
				var tableCell = dom("TD", null, "x"); 
			tableRow.appendChild(tableCell);
		};
		
		this.table = dom("TABLE", {"class": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
		newLetter = this.bag.selectRandomLetter();
		if (this.contains(newLetter) == false) 
			this.store(newLetter, 1);
		else
			this.store(newLetter, this.lookup(newLetter)+1);
		this.bag.remove(newLetter);
	},
	initialHand: function() {
		for (var i = 0; i < HAND_SIZE; i++) {
			this.grabLetter(this.bag);
		};
	},
	clear: function() {
		this.values = {};
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
});
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;

		this.board = [];
		var tbody = dom("TBODY");
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableSquare = dom("TD", null, "x");
				tableRow.appendChild(tableSquare);
				// row.push(Square.create(x, y));
				row.push([x, null]);
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		
		this.table = dom("TABLE", {"class": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			throw "Space not on game board: " + error.message;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.isEmpty(x, y))
			this.board[y][x][1] = letter;
	},
	// Takes array of arrays in the form [x, y]. Are they all in a single row or column? Are all the values adjacent to each other? If so, returns true.
	isInline: function(play) {
		var xValue = play[0][0];
		var yValue = play[0][1];
		if (play[0][0] == play[1][0])
			var row = true;
		else if (play[0][1] = play[1][1])
			var column = true;
		else
			return false;
		for (var i = 1; i < play.length; i++) {
			if (row) {
				// Checks if value is in the same row and if the y value is adjacent to the previous y value
				if ((play[i][0] != xValue) || (play[i][1] != (play[i-1][1] + 1)))
					return false;
			}
			if (column) {
				if ((play[i][1] != yValue) || (play[i][0] != (play[i-1][0] + 1)))
					return false;
			}
		};
		return true;
	},
	// Takes array of arrays in the form [x, y, letter]. Return string from letters placed on board.
	boardToWord: function(play) {
		word = "";
		for (var i = 0; i < play.length; i++) {
			word += play[i][2];
		}
		return word;
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var tile = this.board[i][j][0];
				func(tile, this.valueAt(j, i));
			}
		}
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
};

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		this.place = place;
		this.score = 0;
		
		var newGame = dom("BUTTON", null, "New game");
		addHandler(newGame, "click", function() {location.reload();});
		var newHand = dom("BUTTON", null, "New hand");
		addHandler(newHand, "click", method(this, "newHand"));
		this.container = dom("DIV", null,
							dom("H1", null, ""),
							dom("DIV", null, newGame),
							dom("DIV", null, newHand));
		this.place.appendChild(this.container);
		
		this.initial();
		
		/* Need to write handler for placing tiles: run through childNodes DOM elements to create HAND_SIZE addHandler functions that adds a click handler for each TD element in this.hand.table. Run through childNodes DOM elements of Board to create a click handler for each TD element in this.board.table. Create a function that takes the lastChild of the TD element clicked as an argument. This function will place that letter (DOM element) in the place where the user clicks next. If the click is in a TD cell of the Board, then appendChild is called on that TD to place the letter on the Board. If not, break function. */
	},
	initial: function() {
		if (this.board && this.hand) {
			this.board.removeFromPage(document.body);
			this.hand.removeFromPage(document.body);
		}
		this.score = 0;
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.board.placeToPage(this.container);
		this.bag = Bag.create();
		this.hand = Hand.create(this.bag, null);
		this.hand.placeToPage(this.container);
	},
	newHand: function() {
		if (this.board && this.hand && (this.bag.count() >= 7)) {
			this.hand.clear();
			this.hand.removeFromPage(document.body);
			this.hand = Hand.create(this.bag, null);
			this.hand.placeToPage(document.body);
		}
		else
			throw "Not enough letters in bag";
	},
	placeLetterFromHand: function(x, y, letter) {
		this.hand.remove(letter);
		this.board.placeLetter(x, y, letter);
	},
	updateScore: function(newPoints) {
		this.score += newPoints;
	}
};

function boardToWordTests() {
	testBoard = Board.create(6, 6);
	return testBoard.boardToWord([[1, 2, "D"], [1, 3, "O"], [1, 2, "G"]]) == "DOG" &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) == "UP" &&
		testBoard.boardToWord([[1, 4, "Y"], [2, 4, "O"], [3, 4, "U"]]) == "YOU" &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) == testBoard.boardToWord([[1, 3, "U"], [1, 2, "P"]]) &&
		testBoard.boardToWord([[1, 5, "U"], [1, 2, "P"]]) != "PU";
}
function isInlineTests() {
	var testBoard = Board.create(5, 5);
	return (testBoard.isInline([[1,2], [1,3], [1, 4]]) == true) &&
			(testBoard.isInline([[0, 2], [1, 2], [2, 2]]) == true) &&
			(testBoard.isInline([[0, 3], [0, 4], [0, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 2]]) == false) &&
			(testBoard.isInline([[0, 1], [0, 2], [0, 3], [0, 0]]) == false);
}
function isValidHandTests(testBag) {
	var testHand = Hand.create(testBag, {"B": 1, "A": 2, "Y": 1});
	return testHand.isValidHand("BABY") == false &&
		testHand.isValidHand("BAY") ==  true &&
		testHand.isValidHand("BY") == true &&
		testHand.isValidHand("XBY") == false &&
		testHand.isValidHand("BAAY") == true;
}

var testBag = Bag.create();
console.log("isInline tests: " + isInlineTests());
console.log("isValidHand tests: " + isValidHandTests(testBag));
console.log("boardToWord tests: " + boardToWordTests());

var scrabble = Game.create(document.body);

};
</script>
<body>
</body>
</html>