<html>
<style>
button {
	margin: 5px;
}
.empty {
	background-color: grey;
}
.empty-hand {
}
.placed-letter {
	background-color: green;
}
.selected-letter {
	background-color: red;
}
.error {
	color: red;
}
#board {
	position: relative;
}
#board td{
	width: 50px;
	height: 50px;
	text-align: center;
	font-size: 35px;
}
.sidebar {
	position: absolute;
	align: right;
	width: 30%;
}
#hand {
	margin-top: 10px;
	margin-bottom: 10px;	
}
#hand td{
	width: 50px;
	height: 50px;
	text-align: center;
	font-size: 35px;
}
#messages {
	margin: 10px;
	font-weight: bold;
}
#score {
	margin: 10px;
	font-weight: bold;
}
#scoreString {
	margin: 10px;
	font-weight: bold;
}
</style>
<body>
<!--
VARIANTS:
Solitaire Scrabble- one player, timed
Clabbers- scrabble, but words played only have to be anagrams of real words
Strategy Scrabble- two player, where they can see each others hand

scores single letter twice when played in two words- run through row or column and delete any matches in appendage before scoring

display board specials

layout

inDict (string is in word dictionary)

anagrams:
enter intended anagram. then only need to check if that's an anagram of letters on board, and search dictionary. needs to check for each word played per play

use ajax to load dictionary after board/hand

Deselect old tile and select new tile upon click on different tile.

effects
images

Clean up unneeded functions
Refactor

How to call function as argument?
Re-write findPlayPlus using function handler

lookup: Handlebars tutorial
Place Board and Hand using Handlebars templates

Re-write filtering functions findPlay, etc. using Jquery.grep

How do we access the empty Square objects we create when we create a Board? How do we define multiple variables within a loop? eval? Should we even use a Square object or just add the traits we need to the array?

bug reporting e-mail

BUGS:
TypeError when submitWord is called with no letters played on board
 -->
<script src="jquery-1.9.1.js"></script>
<script type="text/javascript">
$(document).ready(function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 15;
var BOARD_WIDTH = 15;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, "*": 0};

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, "*": 2};

var LETTER_VOWELS = ["A", "E", "I", "O", "U"];

var boardSpecials = [
	['TW', 'none', 'none', 'DL', 'none', 'none', 'none', 'TW', 'none', 'none', 'none', 'DL', 'none', 'none', 'TW'],
	['none', 'DW', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'DW', 'none'],
	['none', 'none', 'DW', 'none', 'none', 'none', 'DL', 'none', 'DL', 'none', 'none', 'none', 'DW', 'none', 'none'],
	['DL', 'none', 'none', 'DW', 'none', 'none', 'none', 'DL', 'none', 'none', 'none', 'DW', 'none', 'none', 'DL'],
	['none', 'none', 'none', 'none', 'DW', 'none', 'none', 'none', 'none', 'none', 'DW', 'none', 'none', 'none', 'none'],
	['none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none'],
	['none', 'none', 'DL', 'none', 'none', 'none', 'DL', 'none', 'DL', 'none', 'none', 'none', 'DL', 'none', 'none'],
	['TW', 'none', 'none', 'DL', 'none', 'none', 'none', 'start', 'none', 'none', 'none', 'DL', 'none', 'none', 'TW'],
	['none', 'none', 'DL', 'none', 'none', 'none', 'DL', 'none', 'DL', 'none', 'none', 'none', 'DL', 'none', 'none'],
	['none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none'],
	['none', 'none', 'none', 'none', 'DW', 'none', 'none', 'none', 'none', 'none', 'DW', 'none', 'none', 'none', 'none'],
	['DL', 'none', 'none', 'DW', 'none', 'none', 'none', 'DL', 'none', 'none', 'none', 'DW', 'none', 'none', 'DL'],
	['none', 'none', 'DW', 'none', 'none', 'none', 'DL', 'none', 'DL', 'none', 'none', 'none', 'DW', 'none', 'none'],
	['none', 'DW', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'TL', 'none', 'none', 'none', 'DW', 'none'],
	['TW', 'none', 'none', 'DL', 'none', 'none', 'none', 'TW', 'none', 'none', 'none', 'DL', 'none', 'none', 'TW']
];
	
var boardSpecialsCheck = function() {
	for (var i = 0; i < boardSpecials.length; i++) {
		if (boardSpecials[i].length != BOARD_WIDTH)
			return false;
	}
	if (boardSpecials.length != BOARD_HEIGHT)
		return false;
	return true;
}
console.log('boardSpecialsCheck: ' + boardSpecialsCheck());

// How many identical values between array1 and array2 where array1 and array2 are composed of arrays of length two
function matches(array1, array2) {
	var count = 0;
	for (var i = 0; i < array1.length; i++) {
		for (var j = 0; j <array2.length; j++) {
			if (array1[i][0] == array2[j][0] && array1[i][1] == array2[j][1])
				count += 1;
		}
	}
	return count;
}

// Returns matches between array1, array2
function matchesArray(array1, array2) {
	matchesArr = [];
	for (var i = 0; i < array1.length; i++) {
		for (var j = 0; j <array2.length; j++) {
			if (array1[i][0] == array2[j][0] && array1[i][1] == array2[j][1])
				matchesArr.push(array1[i]);
		}
	}
	return matchesArr;
}

function removeDuplicatesInArray(play) {
	var uniqueArray = [];
	$.each(play, function(i, element) {
		if ($.inArray(element, uniqueArray) === -1)
			uniqueArray.push(element);
	});
	return uniqueArray;
}

function removeDuplicatePairsInArray(play) {
	var uniqueArray = [];
	$.each(play, function(i, element) {
		if ($.inArray(element, uniqueArray) === -1)
			uniqueArray.push(element);
		else {
			uniqueArray.pop(element);
			console.log(element);
		}
	});
	return uniqueArray;
}

arr = [[1,2], [1,3], [2,4], [4,2], [4,3], [1,3], [4,3]];
console.log(removeDuplicatesInArray(arr));
console.log(removeDuplicatePairsInArray(arr));

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function stringToWord(word) {
	var wordDict = Dictionary.create();
	for (var i = 0; i < word.length; i++) {
		if (wordDict.contains(word[i]) == false) 
			wordDict.store(word[i], 1);
		else
			wordDict.store(word[i], wordDict.lookup(word[i])+1);
	}
	return wordDict.values;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
};

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
};

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
};

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
};

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var Hand = Dictionary.extend({
	construct: function(bag, vowels, startValues) {
		this.bag = bag;
		this.template = $('#hand-template');
		this.values = startValues || {};
		if (startValues == null)
			this.initialHand(vowels);
		var copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", {"id": String(i)}, "*");
				else
					var tableCell = dom("TD", {"id": String(i)}, copy[i]);
				}
			tableRow.appendChild(tableCell);
		};
		
		this.table = dom("TABLE", {"id": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
	if (this.bag.count() > 1) {
		newLetter = this.bag.selectRandomLetter();
		this.addLetter(newLetter);
		this.bag.remove(newLetter);
		return newLetter;
	}
	else
		return null;
	},
	// Insert vowel argument for initialHand. Call with vowels = 0 for newHand method. For new games, run with certain vowel limit so that the first integer 'vowels' selections are vowels. Dive into Bag and select letter. If it's a vowel, place in hand and remove from bag. If not, do nothing and try again. Once vowels limit is reached, continue on normally, but now select only consonants.
	// How to search array for string?
	initialHand: function(vowels) {
		var count = 0;
		for (var i = 0; i < HAND_SIZE-vowels; i++) {
			while (count < vowels) {
				var letter = this.bag.selectRandomLetter();
				if (LETTER_VOWELS.indexOf(letter) != -1) {
						this.addLetter(letter);
						this.bag.remove(letter);
						count += 1;
					}
				}
			var check = true;
			while (check) {
				var letter = this.bag.selectRandomLetter();
				if (LETTER_VOWELS.indexOf(letter) == -1) {
					this.addLetter(letter);
					this.bag.remove(letter);
					check = false;
				}
			}
		}
	},
	removeLetter: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Hand doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	addLetter: function(letter) {
		if (this.contains(letter) == false) 
			this.store(letter, 1);
		else
			this.store(letter, this.lookup(letter)+1);
	},
	clear: function() {
		this.values = {};
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
});

/*
var Square = {
	construct: function(x, y) {
		this.x = x;
		this.y = y;
		this.letter = "  ";
		this.lock = false;
		this.special = false;
	},
	isEmpty: function() {
		return this.letter == "  ";
	},
	setLock: function() {
		this.lock = true;
	},
	getLock: function() {
		return this.lock;
	},
	setLetter: function(letter) {
		this.letter = letter;
	},
	getLetter: function() {
		return this.letter;
	},
	isSpecial: function() {
		return this.special;
	}
};	
*/
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;
		var lock = true;

		this.board = [];
		var tbody = dom("TBODY"),
			count = 0;
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableSquare = dom("TD", {"id": String(x) + "-" + String(y), "class": "empty", "data-special": boardSpecials[count]}, "  ");
				tableRow.appendChild(tableSquare);
				// row.push(Square.create(x, y));
				row.push([lock, null]);
				count += 1;
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		this.table = dom("TABLE", {"id": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			return null;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.isEmpty(x, y)) {
			this.board[y][x][1] = letter;
			this.setLock(x, y, false);
		}
	},
	removeLetter: function(x, y) {
		this.board[y][x][1] = null;
	},
	// Sets lock to boolean 'value'. 'true' if one can't move the space, such as in an empty space or a letter that has already been played. 'false' if one can move the letter such as in rearranging letters for a play
	setLock: function(x, y, value) {
		this.board[y][x][0] = value;
	},
	getLock: function(x, y) {
		return this.board[y][x][0];
	},
	rowOrColumn: function(play) {
		if (play.length < 2)
			return "single";
		if (play[0][0] == play[1][0])
			return "column";
		else if (play[0][1] == play[1][1])
			return "row";
		else
			return false;
	},
	// Takes array of arrays in the form [x, y]. Are they all in a single row or column? Are all the values adjacent to each other? If so, returns true. Requires there are at least two tiles played.
	isInline: function(play) {
		var xValue = play[0][0],
			yValue = play[0][1],
			rowOrColumn = this.rowOrColumn(play);
		if (rowOrColumn) {
			for (var i = 1; i < play.length; i++) {
				if (rowOrColumn == "column") {
					// Checks if value is in the same row and if the y value is adjacent to the previous y value
					if ((play[i][0] != xValue) || (play[i][1] != (play[i-1][1] + 1)))
						return false;
				}
				else if (rowOrColumn == "row") {
					if ((play[i][1] != yValue) || (play[i][0] != (play[i-1][0] + 1)))
						return false;
				}
				else if (rowOrColumn == "single")
					return true;
			};
		}
		else
			return false;
		return true;
	},
	isInSameRowOrColumn: function(play) {
		var xValue = play[0][0],
			yValue = play[0][1],
			xCheck = true,
			yCheck = true;
		for (var i = 1; i < play.length; i++) {
			if (xValue != play[i][0])
				xCheck = false;
			if (yValue != play[i][1])
				yCheck = false;
		}
		return (yCheck || xCheck);
	},
	// Scans board with play from findPlay plus the letters that are already on the board that the player is playing from
	// Checks if letter is placed on board after the row of tiles that are represented by play. If so, places letter in play array. Runs itself again to check.
	// findPlayPlus start with the first tile from findPlay. Then scan the board from that first tile to determine the next in line. If there's a next one, add it to playPlus. If not, break. These tiles for which it scans can be locked or unlocked.
	// From each new sequence in the loop, check left or right if it's a column, up or down if it's a row, to determine a possible new word. Add all those possible new array words to returned object as optional attributes
	// Determine whether play is row or column. If it's a row, run row functions. Once completed, run column functions to determine appendages. Keep track of column appendages in object.appendages.
	findPlayPlus: function(play) {
		var first = play[0],
			row = [first],
			column = [first],
			playPlus = {row: null, column: null, appendages: []};
		var rowAfter = this.rowAfterPlay(row);
		while (rowAfter) {
			row.push(rowAfter);
			rowAfter = this.rowAfterPlay(row);
		}
		var rowBefore = this.rowBeforePlay(row);
		while (rowBefore) {
			row.unshift(rowBefore)
			rowBefore = this.rowBeforePlay(row);
		}
		if ((row.length > 1) && (matches(row, play) > 1)) {
			for (var i = 0; i < row.length; i++) {
					var appendage = [row[i]];
					if (matches(appendage, play) > 0) {
						var columnAfter = this.columnAfterPlay(appendage);
						while (columnAfter) {
							appendage.push(columnAfter);
							columnAfter = this.columnAfterPlay(appendage);
						}
						var columnBefore = this.columnBeforePlay(appendage);
						while (columnBefore) {
							appendage.unshift(columnBefore);
							columnBefore = this.columnBeforePlay(appendage);
						}
						if (appendage.length > 1) {
							playPlus.appendages.push(appendage);
						}
				}
			}
			playPlus.row = row;
			console.log(playPlus);
			return playPlus;
		}
		var columnAfter = this.columnAfterPlay(column);
		while (columnAfter) {
			column.push(columnAfter);
			columnAfter = this.columnAfterPlay(column);
		}
		var columnBefore = this.columnBeforePlay(column);
		while (columnBefore) {
			column.unshift(columnBefore);
			columnBefore = this.columnBeforePlay(column);
		}
		if ((column.length > 1) && (matches(column, play) > 1)) {
			for (var i = 0; i < column.length; i++) {
				var appendage = [column[i]];
				if (matches(appendage, play) > 0) {
					var rowAfter = this.rowAfterPlay(appendage);
					while (rowAfter) {
						appendage.push(rowAfter);
						rowAfter = this.rowAfterPlay(appendage);
					}
					var rowBefore = this.rowBeforePlay(appendage);
					while (rowBefore) {
						appendage.unshift(rowBefore)
						rowBefore = this.rowBeforePlay(appendage);
					}
					if (appendage.length > 1) {
						playPlus.appendages.push(appendage);
					}
				}
			}
			playPlus.column = column;
			console.log(playPlus);
			return playPlus;
		}
		// If the play is only one letter
		if (play.length == 1) {
			if (row.length > 1)
				playPlus.row = row;
			if (column.length > 1 && playPlus.row == null)
				playPlus.column = column;
			if (column.length > 1 && playPlus.row != null)
				playPlus.appendages.push(column);
			return playPlus;
		}
		return play;
	},
	// TODO: How to pass function with arguments to object when we don't know function's name?
	playPlusHandler: function(fn) {
		var fn = this[fn](play);
		while (fn) {
			playPlus.push(fn);
			fn = this[fn](play);
		}
	},
	rowAfterPlay: function(play) {
		var lastInRow = play[play.length-1];
		if (this.valueAt(lastInRow[0]+1, lastInRow[1]))
			return [lastInRow[0]+1, lastInRow[1]];
		else
			return null;
	},
	rowBeforePlay: function(play) {
		var firstInRow = play[0];
		if (this.valueAt(firstInRow[0]-1, firstInRow[1]))
			return [firstInRow[0]-1, firstInRow[1]];
		else
			return null;
	},
	columnAfterPlay: function(play) {
		var lastInColumn = play[play.length-1];
		if (this.valueAt(lastInColumn[0], lastInColumn[1]+1))
			return [lastInColumn[0], lastInColumn[1]+1];
		else
			return null;
	},
	columnBeforePlay: function(play) {
		var firstInColumn = play[0];
		if (this.valueAt(firstInColumn[0], firstInColumn[1]-1))
			return [firstInColumn[0], firstInColumn[1]-1];
		else
			return null;
	},
	// Scans board for letters with a lock of false to determine the play
	findPlay: function() {
		play = [];
		for (var y = 0; y < this.height; y++) {
			for (var x = 0; x < this.width; x++) {	
				if (this.board[y][x][0] == false)
					play.push([x, y]);
			}
		}
		return play;
	},	
	// Sets play as permanent; i.e., 'locks' tiles on board
	setPlay: function(play) {
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			this.board[y][x][0] = true;
		}
	},
	// Given a playPlus object, count the number of unlocked tiles in that play given a Board
	countUnlocked: function(playPlus) {
		var count = 0;
		if (playPlus.row) {
			for (var i = 0; i < playPlus.row.length; i++) {
				var x = playPlus.row[i][0];
				var y = playPlus.row[i][1];
				if (this.getLock(x, y) == false)
					count += 1;
			}
		}
		if (playPlus.column) {
			for (var i = 0; i < playPlus.column.length; i++) {
				var x = playPlus.column[i][0];
				var y = playPlus.column[i][1];
				if (this.getLock(x, y) == false)
					count += 1;
			}
		}
		return count;
	},
	// Creates array of square locations from playPlus object
	playPlusArray: function(play) {
		var playArray = [];
		if (play.row) {
			$.each(play.row, function(i, element) {
				playArray.push(play.row[i]);
			});
		}
		if (play.column) {
			$.each(play.column, function(i, element) {
				playArray.push(play.column[i]);
			});
		}
		if (play.appendages) {
			$.each(play.appendages, function(i, element) {
				for (var j = 0; j < play.appendages[i].length; j++) {
					playArray.push(play.appendages[i][j]);
				}
			});
		}
		return playArray;
	},
	// Takes play array (array of array locations) and returns score
	scorePlay: function(play) {
		var score = 0,
			self = this,
			TW = false,
			DW = false;
		$.each(play, function(i, element) {
			if (boardSpecials[element[1]][element[0]] == 'TW')
				TW = true;
			if (boardSpecials[element[1]][element[0]] == 'DW')
				DW = true;
			if (boardSpecials[element[1]][element[0]] == 'TL')
				score += LETTER_VALUES[self.valueAt(element[0], element[1])]*3;
			else if (boardSpecials[element[1]][element[0]] == 'DL')
				score += LETTER_VALUES[self.valueAt(element[0], element[1])]*2;
			else
				score += LETTER_VALUES[self.valueAt(element[0], element[1])];
		});
		if (TW)
			score *= 3;
		if (DW)
			score *= 2;
		return score;
	},
	// Takes playPlus object (column: array, row: array, appendages: array of arrays) returns score based on scorePlay
	scorePlayPlus: function(playPlus) {
		var score = 0,
			self = this,
			row = playPlus.row,
			column = playPlus.column,
			appendages = playPlus.appendages;
		if (row) {
			score += self.scorePlay(row);
			console.log('row score: ' + self.scorePlay(row));
		}
		if (column) {
			score += self.scorePlay(column);
			console.log('column score: ' + self.scorePlay(column));
		}
		if (appendages.length > 0) {
			$.each(appendages, function(i, element) {
				var elementArr = element;
				if (row) {
					var repeats = matchesArray(row, appendages[i]);
					$.each(row, function(i, element) {
						elementArr.push(element);
					});
				}
				if (column) {
					var repeats = matchesArray(column, appendages[i]);
					$.each(column, function(i, element) {
						elementArr.push(element);
					});
				}
				console.log(elementArr);
				var elementWithoutDuplicates = removeDuplicatePairsInArray(elementArr);
				console.log(elementWithoutDuplicates);
				score += self.scorePlay(elementWithoutDuplicates);
				console.log('appendage score: ' + self.scorePlay(elementWithoutDuplicates));
			});
		}
		console.log('total score: ' + score);
		return score;
	},
	scorePlayString: function(play) {
		var score = "",
			self = this,
			TW = false,
			DW = false;
		$.each(play, function(i, element) {
			if (boardSpecials[element[1]][element[0]] == 'TW') {
				TW = true;
				score = "TRIPLE WORD SCORE".concat(score);
			}
			if (boardSpecials[element[1]][element[0]] == 'DW') {
				DW = true;
				score = "DOUBLE WORD SCORE".concat(score);
			}
			if (boardSpecials[element[1]][element[0]] == 'TL') {
				score += "\n" + self.valueAt(element[0], element[1]) + ": " + LETTER_VALUES[self.valueAt(element[0], element[1])] + "*3 = "
				+ LETTER_VALUES[self.valueAt(element[0], element[1])]*3;
			}
			else if (boardSpecials[element[1]][element[0]] == 'DL') {
				score += "\n" + self.valueAt(element[0], element[1]) + ": " + LETTER_VALUES[self.valueAt(element[0], element[1])] + "*2 = "
				+ LETTER_VALUES[self.valueAt(element[0], element[1])]*2;
			}
			else {
				score += "\n" + self.valueAt(element[0], element[1]) + ": " + LETTER_VALUES[self.valueAt(element[0], element[1])];
			}
		});
		return score;
	},
	scorePlayPlusString: function(playPlus) {
		var score = "",
			self = this,
			row = playPlus.row,
			column = playPlus.column,
			appendages = playPlus.appendages;
		if (row) {
			score += self.scorePlayString(row);
		}
		if (column) {
			score += self.scorePlayString(column);
		}
		if (appendages.length > 0) {
			$.each(appendages, function(i, element) {
				score += "\n&&&&&&";
				score += self.scorePlayString(element);
			});
		}
		return score;
	},
	// Disables board specials after a play is made on them by deleting the special from the boardSpecial array.
	deactivateBoardSpecials: function(play) {
		$.each(play, function(i, element) {
			boardSpecials[element[1]][element[0]] = 'none';
		});
	},
	// Takes array of arrays in the form [x, y]. Return string from letters placed on board.
	boardToWord: function(play) {
		word = "";
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			word += this.board[y][x][1];
		}
		return word;
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var lock = this.board[i][j][0];
				func(lock, this.valueAt(j, i));
			}
		}
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
};

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		this.place = place;
		this.score = 0;
		this.letterEvent = null;
		
		this.initial();
		
		$('<button id="newGame">New game</button>').appendTo(this.place);
		$('#newGame').on('click', function() {
			location.reload();
			});
			
		$('<button id="newHand">Swap tiles</button>').appendTo(this.place);
		$('#newHand').on('click', method(this, 'newHand'));
		
		$('<button id="returnTiles">Return tiles</button>').appendTo(this.place);
		$('#returnTiles').on('click', method(this, 'returnTiles'));
		
		$('<button id="submitWord">Submit word</button>').appendTo(this.place);
		$('#submitWord').on('click', method(this, 'submitWord'));

		$('<div id="score">&nbsp;</div>').appendTo(this.place);
		$('<div id="scoreString">&nbsp;</div>').appendTo(this.place);
		$('<div id="messages">&nbsp;</div>').appendTo(this.place);
		
		var self = this;
		
		//children().children().children() means #hand table -> tbody -> tr -> td
		//Hand click handlers
		$('#hand').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				// Placing a letter back in hand
				if (self.letterEvent && $this.text() == "  ") {
					$this.text(self.letterEvent[0]);
					$this.removeClass("empty").removeClass("empty-hand");
					
					$id = $('#' + self.letterEvent[1])
					var square = $id.attr('id');
					$id.removeClass("selected-letter")
						.text("  ");
					// Determining whether letter was grabbed from board
					if (self.letterEvent[1].length >= 2) {
						square = square.split("-");
						self.hand.addLetter(self.letterEvent[0]);
						self.board.removeLetter(square[0], square[1]);
						self.board.setLock(square[0], square[1], true);
						$id.addClass('empty')
							.removeClass('placed-letter');
					}
					else
						$id.addClass('empty-hand');
					self.letterEvent = null;
				}
				// Grabbing letter from hand
				else if (!self.letterEvent && $this.text() != "  ") {
					$this.addClass("selected-letter");
					self.letterEvent = [$this.text(), $this.attr("id")];
				}
				else if (self.letterEvent && $this.text() == self.letterEvent[0]) {
					self.deselectHandler(self.letterEvent);
					self.letterEvent = null;
				}
			});
		});
		
		//children().children().children() means #board table -> tbody -> tr -> td
		//Board click handlers
		$('#board').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				var square = $this.attr("id"),
					square = square.split("-");
				// Place letter on board
				if ((self.letterEvent) && (self.board.isEmpty(square[0], square[1]))) {
					self.board.placeLetter(square[0], square[1], self.letterEvent[0]);
					$('#' + String(square[0]) + "-" + String(square[1])).text(self.letterEvent[0])
																	.removeClass('empty')
																	.addClass('placed-letter');
					
					$id = $('#' + self.letterEvent[1])
					square = $id.attr('id');
					$id.removeClass("selected-letter");
					if (self.letterEvent[1].length < 2) {
						self.hand.removeLetter($id.text());
						$id.addClass('empty-hand');
					}
					else {
						square = square.split("-");
						self.board.removeLetter(square[0], square[1]);
						self.board.setLock(square[0], square[1], true);
						$id.addClass('empty')
							.removeClass('placed-letter');
					}
					$id.text("  ");
					self.letterEvent = null;
				}
				// Grab letter from board
				else if ((!self.letterEvent) && (self.board.getLock(square[0], square[1]) == false)) {
					self.letterEvent = [$this.text(), $this.attr("id")];
					$this.addClass("selected-letter");
				}
				else if (self.letterEvent && $this.text() == self.letterEvent[0]) {
					self.deselectHandler(self.letterEvent);
					self.letterEvent = null;
				}				
			});
		});
	},
	deselectHandler: function(letterEvent) {
		var $id = $('#' + letterEvent[1]);
		$id.text(letterEvent[0]);
		$id.removeClass("selected-letter");
	},
	initial: function() {
		if (this.board && this.hand) {
			this.board.removeFromPage(this.place);
			this.hand.removeFromPage(this.place);
		}
		this.score = 0;
		this.first = true;
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.board.placeToPage(this.place);
		this.bag = Bag.create();
		this.hand = Hand.create(this.bag, 2, null);
		this.hand.placeToPage(this.place);
	},
	submitWord: function() {
		var play = this.board.findPlay(),
			countPlay = play.length,
			playPlus = this.board.findPlayPlus(play),
			playPlusArray = this.board.playPlusArray(playPlus),
			playPlusWithoutDuplicates = removeDuplicatesInArray(playPlusArray),
			score = this.board.scorePlayPlus(playPlus),
			countUnlockedPlayPlus = this.board.countUnlocked(playPlus),
			row = playPlus.row,
			column = playPlus.column,
			self = this,
			error = false,
			blank = false,
			check = true;
		if (row)
			countPlayPlusRow = playPlus.row.length;
		if (column)
			countPlayPlusColumn = playPlus.column.length;
		var submitWordHelper = function(rowOrColumn) {
			// Check if play includes at least one letter already placed on board
			if (rowOrColumn == row)
				var countPlayPlus = countPlayPlusRow;
			if (rowOrColumn == column)
				var countPlayPlus = countPlayPlusColumn;
			if (countPlayPlus == countPlay && self.first == false && playPlus.appendages.length < 1) {
					check = false;
			}
			console.log(playPlus);
			var word = self.board.boardToWord(rowOrColumn);
			if (word.contains("*")) {
				var blankLetter = prompt("Enter letter for blank (*) tile");
				blank = true;
				}
			if (blank && blankLetter) {
				// Replace * with letter chosen
				blank = false;
				blankLetter = blankLetter.toUpperCase().slice(0,1);
				$('#board').children().children().children().each( function() {
					var square = $(this).attr("id"),
						square = square.split("-");
					if (self.board.valueAt(square[0], square[1]) == "*") {
						self.board.removeLetter(square[0], square[1]);
						self.board.placeLetter(square[0], square[1], blankLetter);
						$('#' + square[0] + '-' + square[1]).text(blankLetter);
					}
				});
				word = self.board.boardToWord(rowOrColumn);
			}
			if (self.board.isInline(rowOrColumn) && check && self.board.isInSameRowOrColumn(play) && countPlay <= countUnlockedPlayPlus && !(word.contains('*'))) {
				self.letterEvent = null;
				self.replenishHand(countPlay);
				self.board.setPlay(play);
				self.setPlayStyle(play);
				self.first = false;
				console.log(boardSpecials);
				var playPlusAppendages = function(playPlus) {
					var message = [];
					if (playPlus.appendages.length > 0) {
						$.each(playPlus.appendages, function( index, element ) {
							message.push(self.board.boardToWord(element));
						});
					}
					return message;
				}
				
				self.updateScore(score);
				var message = "Valid play: " + word,
					playPlusAppendagesArray = playPlusAppendages(playPlus);
				if (playPlusAppendagesArray.length > 0)
					message += ", " + playPlusAppendagesArray.join(", ");
				$('#messages').text(message)
					.removeClass('error');
				var playPlusArray = removeDuplicatesInArray(self.board.playPlusArray(playPlus));
				$('#scoreString').text(self.board.scorePlayPlusString(playPlus));
				self.board.deactivateBoardSpecials(playPlusWithoutDuplicates);
			}
			else {
				error = true;
				$('#messages').text("Invalid word")
								.addClass('error');
			}
		}
		if (row)
			submitWordHelper(row);
		else if (column)
			submitWordHelper(column);
	},
	newHand: function() {
		if (this.board && this.hand && (this.bag.count() >= HAND_SIZE) && (this.board.findPlay().length < 1)) {
			this.hand = Hand.create(this.bag, 0, null);
			var hand = this.hand.createArray();
			for (var i = 0; i < HAND_SIZE; i++) {
				$square = $('#' + i)
							.removeClass('selected-letter')
							.text(hand[i]);
			}
		}
		else if (this.bag.count() < HAND_SIZE)
			$('#messages').text("Bag out of letters").addClass('error');
		else if (this.board.findPlay().length >= 1)
			$('#messages').text("To swap tiles, all tiles must be returned to hand").addClass('error');
	},
	returnTiles: function() {
		var play = this.board.findPlay();
		for (var i = 0; i < play.length; i++) {
			var letter = this.board.valueAt(play[i][0], play[i][1]);
			this.board.removeLetter(play[i][0], play[i][1]);
			var $square = $('#' + play[i][0] + "-" + play[i][1])
				.text(" ")
				.addClass('empty')
				.removeClass('placed-letter')
				.removeClass('selected-letter');
			this.board.setLock(play[i][0], play[i][1]);
			this.hand.addLetter(letter);
			var $space = $('.empty-hand')
										.first()
										.text(letter)
										.removeClass('empty-hand');
		}
		this.setPlayStyle(play);
	},	
	replenishHand: function(count) {
		for (var i = 0; i < count; i++) {
			var letter = this.hand.grabLetter();
			if (!letter) {
				$('#messages').text("Bag out of letters");
			}
			var $space = $('.empty-hand')
										.first()
										.text(letter)
										.removeClass('empty-hand');
		}
	},
	// Removes styling for letters placed on board during play
	setPlayStyle: function(play) {
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			$('#' + x + "-" + y).removeClass('placed-letter').removeClass('selected-letter');
		}
	},
	updateScore: function(newPoints) {
		this.score += newPoints;
		$('#score').text("Word score: " + newPoints + ", Total score: " + this.score);
	}
};

function isInlineTests() {
	var testBoard = Board.create(5, 5);
	return (testBoard.isInline([[1,2], [1,3], [1, 4]]) == true) &&
			(testBoard.isInline([[0, 2], [1, 2], [2, 2]]) == true) &&
			(testBoard.isInline([[0, 3], [0, 4], [0, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 2]]) == false) &&
			(testBoard.isInline([[0, 1], [0, 2], [0, 3], [0, 0]]) == false) &&
			(testBoard.isInline([[0, 0], [1, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 0]]) == false);
}
function rowOrColumnTests() {
	var testBoard = Board.create(5, 5);
	return testBoard.rowOrColumn([[0, 2], [1, 2], [2, 2]]) == "row" &&
			(testBoard.rowOrColumn([[1, 2], [1, 3], [1, 4]]) == "column") &&
			(testBoard.rowOrColumn([[0, 3], [0, 4], [0, 1]]) == "column") &&
			(testBoard.rowOrColumn([[0, 1], [1, 2]]) == false) &&
			(testBoard.rowOrColumn([[0, 1], [1, 0]]) == false) &&
			(testBoard.rowOrColumn([[0, 1]]) == "single");
}
function isValidHandTests(testBag) {
	var testHand = Hand.create(testBag, 0, {"B": 1, "A": 2, "Y": 1});
	return testHand.isValidHand("BABY") == false &&
		testHand.isValidHand("BAY") ==  true &&
		testHand.isValidHand("BY") == true &&
		testHand.isValidHand("XBY") == false &&
		testHand.isValidHand("BAAY") == true;
}

console.log("rowOrColumn tests: " + rowOrColumnTests());
console.log("isInline tests: " + isInlineTests());
var testBag = Bag.create();
console.log("isValidHand tests: " + isValidHandTests(testBag));

var scrabble = Game.create(document.body);

});
</script>
</body>
</html>