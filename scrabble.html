<html>
<script>
/*
isValidWord (string is in word dictionary)
Board.isInline (are the tiles in the possible play all in a horizontal or vertical line?)
Play.isValidPlay (fits on board with current arrangement)
	use same pattern as isValidHand but add characters on board to the copy of the hand in the correct positions
Game click handlers for placing letters
Play.placeLetterFromHand
Play.score
Play.updateScore

Board different special bonus positions
Turn
Player

images
*/

window.onload = function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 10;
var BOARD_WIDTH = 10;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, " ": 0}

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, " ": 2}

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

function calculateWordScore(word) {
	score = 0;
	forEachIn(word, function(letter, count) {
		score += LETTER_VALUES[letter] * count;
	});
	return score;
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
}

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
}

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
}

function registerEventHandler(node, event, handler) {
  if (typeof node.addEventListener == "function")
    node.addEventListener(event, handler, false);
  else
    node.attachEvent("on" + event, handler);
}

function addHandler(node, type, handler) {
  function wrapHandler(event) {
    handler(window.event);
  }
  registerEventHandler(node, type, wrapHandler);
  return {node: node, type: type, handler: wrapHandler};
}

function removeHandler(object) {
  unregisterEventHandler(object.node, object.type, object.handler);
}

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
}

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var bag = Bag.create();

var Hand = Dictionary.extend({
	construct: function() {
		this.values = {}
		this.initialHand();
		copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", null, "x");
				else
					var tableCell = dom("TD", null, copy[i]);
				}
			else
				var tableCell = dom("TD", null, "x"); 
			tableRow.appendChild(tableCell);
			};
		
		this.table = dom("TABLE", {"class": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
		newLetter = bag.selectRandomLetter();
		if (this.contains(newLetter) == false) 
			this.store(newLetter, 1);
		else
			this.store(newLetter, this.lookup(newLetter)+1);
		bag.remove(newLetter);
	},
	initialHand: function() {
		for (var i = 0; i < HAND_SIZE; i++) {
			this.grabLetter();
		};
	},
	place: function(where) {
		where.appendChild(this.table);
	},
	remove: function(where) {
		removeElement(this.table);
	}
});

function isValidHandTests() {
	hand = new Hand({"A": 2, "B": 1, "Y": 1});
	return hand.isValidHand("BABY") == false &&
		hand.isValidHand("BAY") ==  true &&
		hand.isValidHand("BY") == true &&
		hand.isValidHand("XBY") == false &&
		hand.isValidHand("BAAY") == true
};
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;

		this.board = [];
		var tbody = dom("TBODY");
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableCell = dom("TD", null, "x");
				tableRow.appendChild(tableCell);
				row.push([x, null]);
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		
		this.table = dom("TABLE", {"class": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			throw "Space not on game board: " + error.message;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.valueAt(x, y) == null)
			this.board[y][x][1] = letter;
	},
	isInline: function(play) {
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var tile = this.board[i][j][0];
				func(tile, this.valueAt(j, i));
			}
		}
	},
	place: function(where) {
		where.appendChild(this.table);
	},
	remove: function(where) {
		removeElement(this.table);
	}
};

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		
		var newGame = dom("BUTTON", null, "New game");
		addHandler(newGame, "click", method(this, "newGame"));
		this.container = dom("DIV", null,
							dom("H1", null, ""),
							dom("DIV", null, newGame));
		place.appendChild(this.container);
		
		this.newGame();
		
		/* Run through childNodes DOM elements to create HAND_SIZE addHandler functions that add a click handler for each TD element in this.hand.table. Run through childNodes DOM elements of Board to create a click handler for each TD element in this.board.table. Create a function that takes the lastChild of the TD element clicked as an argument. This function will place that letter (DOM element) in the place where the user clicks next. If the click is in a TD cell of the Board, then appendChild is called on that TD to place the letter on the Board. If not, break function. */
	},
	newGame: function() {
		if (this.board)
			this.board.remove(document.body);
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.bag = Bag.create();
		this.hand = Hand.create();
		this.board.place(this.container);
		this.hand.place(this.container);
	}
};

var scrabble = Game.create(document.body);

}
</script>
<body>
</body>
</html>