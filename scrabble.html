<html>
<script>
/*
isValidWord (string is in word dictionary)
Play.isValidPlay (fits on board with current arrangement)
	use same pattern as isValidHand but add characters on board to the copy of the hand in the correct positions
Game click handlers for placing letters
Play.placeLetterFromHand
Play.score
Play.updateScore

Board different special bonus positions
Turn
Player

images
*/

window.onload = function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 10;
var BOARD_WIDTH = 10;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, " ": 0}

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, " ": 2}

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

function calculateWordScore(word) {
	score = 0;
	forEachIn(word, function(letter, count) {
		score += LETTER_VALUES[letter] * count;
	});
	return score;
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
};

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
};

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
};

function registerEventHandler(node, event, handler) {
  if (typeof node.addEventListener == "function")
    node.addEventListener(event, handler, false);
  else
    node.attachEvent("on" + event, handler);
};

function addHandler(node, type, handler) {
  function wrapHandler(event) {
    handler(window.event);
  }
  registerEventHandler(node, type, wrapHandler);
  return {node: node, type: type, handler: wrapHandler};
}

function removeHandler(object) {
  unregisterEventHandler(object.node, object.type, object.handler);
}

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
};

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var Hand = Dictionary.extend({
	construct: function(bag, startValues) {
		this.bag = bag;
		this.values = startValues || {};
		if (startValues == null)
			this.initialHand();
		copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", null, "x");
				else
					var tableCell = dom("TD", null, copy[i]);
				}
			else
				var tableCell = dom("TD", null, "x"); 
			tableRow.appendChild(tableCell);
		};
		
		this.table = dom("TABLE", {"class": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
		newLetter = this.bag.selectRandomLetter();
		if (this.contains(newLetter) == false) 
			this.store(newLetter, 1);
		else
			this.store(newLetter, this.lookup(newLetter)+1);
		this.bag.remove(newLetter);
	},
	initialHand: function() {
		for (var i = 0; i < HAND_SIZE; i++) {
			this.grabLetter(this.bag);
		};
	},
	clear: function() {
		this.values = {};
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
});
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;

		this.board = [];
		var tbody = dom("TBODY");
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableSquare = dom("TD", null, "x");
				tableRow.appendChild(tableSquare);
				row.push([x, null]);
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		
		this.table = dom("TABLE", {"class": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			throw "Space not on game board: " + error.message;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.valueAt(x, y) == null)
			this.board[y][x][1] = letter;
	},
	// Takes array of arrays in the form [x, y]. Are they all in a single row or column? Are all the values adjacent to each other? If so, returns true.
	isInline: function(play) {
		var xValue = play[0][0];
		var yValue = play[0][1];
		if (play[0][0] == play[1][0])
			var row = true;
		else if (play[0][1] = play[1][1])
			var column = true;
		else
			return false;
		for (var i = 1; i < play.length; i++) {
			if (row) {
				// Checks if value is in the same row and if the y value is adjacent to the previous y value
				if ((play[i][0] != xValue) || (play[i][1] != (play[i-1][1] + 1)))
					return false;
			}
			if (column) {
				if ((play[i][1] != yValue) || (play[i][0] != (play[i-1][0] + 1)))
					return false;
			}
		};
		return true;
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var tile = this.board[i][j][0];
				func(tile, this.valueAt(j, i));
			}
		}
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
};

function isInlineTests() {
	var testBoard = Board.create(5, 5);
	return (testBoard.isInline([[1,2], [1,3], [1, 4]]) == true) &&
			(testBoard.isInline([[0, 2], [1, 2], [2, 2]]) == true) &&
			(testBoard.isInline([[0, 3], [0, 4], [0, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 2]]) == false) &&
			(testBoard.isInline([[0, 1], [0, 2], [0, 3], [0, 0]]) == false)
};

function isValidHandTests(testBag) {
	var testHand = Hand.create(testBag, {"B": 1, "A": 2, "Y": 1});
	return testHand.isValidHand("BABY") == false &&
		testHand.isValidHand("BAY") ==  true &&
		testHand.isValidHand("BY") == true &&
		testHand.isValidHand("XBY") == false &&
		testHand.isValidHand("BAAY") == true
};

var testBag = Bag.create();
console.log("isInline tests: " + isInlineTests());
console.log("isValidHand tests: " + isValidHandTests(testBag));

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		this.place = place;
		
		var newGame = dom("BUTTON", null, "New game");
		addHandler(newGame, "click", function() {location.reload();});
		var newHand = dom("BUTTON", null, "New hand");
		addHandler(newHand, "click", method(this, "newHand"));
		this.container = dom("DIV", null,
							dom("H1", null, ""),
							dom("DIV", null, newGame),
							dom("DIV", null, newHand));
		this.place.appendChild(this.container);
		
		this.initial();
		
		/* Run through childNodes DOM elements to create HAND_SIZE addHandler functions that adds a click handler for each TD element in this.hand.table. Run through childNodes DOM elements of Board to create a click handler for each TD element in this.board.table. Create a function that takes the lastChild of the TD element clicked as an argument. This function will place that letter (DOM element) in the place where the user clicks next. If the click is in a TD cell of the Board, then appendChild is called on that TD to place the letter on the Board. If not, break function. */
	},
	initial: function() {
		if (this.board && this.hand) {
			this.board.removeFromPage(document.body);
			this.hand.removeFromPage(document.body);
		}
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.board.placeToPage(this.container);
		this.bag = Bag.create();
		this.hand = Hand.create(this.bag, null);
		this.hand.placeToPage(this.container);
	},
	newHand: function() {
		if (this.board && this.hand && (this.bag.count() >= 7)) {
			this.hand.clear();
			this.hand.removeFromPage(document.body);
			this.hand = Hand.create(this.bag, null);
			this.hand.placeToPage(document.body);
		}
		else
			throw "Not enough letters in bag";
	},
	isValidPlay: function() {
		copy = this.hand.createArray();
		
	}
};

var scrabble = Game.create(document.body);

};
</script>
<body>
</body>
</html>