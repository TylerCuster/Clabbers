<html>
<style>
button {
	margin: 5px;
}
.empty {
	background-color: grey;
}
.empty-hand {
}
.placed-letter {
	background-color: green;
}
.selected-letter {
	background-color: red;
}
.error {
	color: red;
}
#board {
	position: relative;
}
#board td{
	width: 50px;
	height: 50px;
	text-align: center;
	font-size: 35px;
}
#hand {
	margin-top: 10px;
	margin-bottom: 10px;	
}
#hand td{
	width: 50px;
	height: 50px;
	text-align: center;
	font-size: 35px;
}
#messages {
	margin: 10px;
	font-weight: bold;
}
#score {
	margin: 10px;
	font-weight: bold;
}
</style>
<body>
<script src="jquery-1.9.1.js"></script>
<script type="text/javascript">
/*
VARIANTS:
Solitaire Scrabble- one player, timed
Strategy Scrabble- two player, where they can see each others hand
Clabbers- scrabble, but words played only have to be anagrams of real words

Re-write findPlayPlus to include single tiles and locked tiles placed in middle of play

Deselect old tile and select new tile upon click on different tile.
When word is submitted with letter highlighted, that highlighted letter isn't 'locked'

isValidWord (string is in word dictionary)

Write:
Swap Tiles
Withdraw Tiles

Board different special bonus positions

effects
images

Clean up unneeded functions
Refactor

Place Board using JQUERY?
Place Hand using JQUERY?

How do we access the empty Square objects we create when we create a Board? How do we define multiple variables within a loop? eval? Should we even use a Square object or just add the traits we need to the array?

BUGS:
*/
$(document).ready(function() {

var HAND_SIZE = 7;
var BOARD_HEIGHT = 8;
var BOARD_WIDTH = 8;

var LETTER_VALUES = {"A": 1, "B": 3, "C": 3, "D": 2, "E": 1, "F": 4, "G": 2, "H": 4, "I": 1, "J": 8, "K": 5, "L": 1, "M": 3, "N": 1, "O": 1, "P": 3, "Q": 10, "R": 1, "S": 1, "T": 1, "U": 1, "V": 4, "W": 4, "X": 8, "Y": 4, "Z": 10, "*": 0}

var LETTER_COUNTS = {"A": 9, "B": 2, "C": 2, "D": 4, "E": 12, "F": 2, "G": 3, "H": 2, "I": 9, "J": 1, "K": 1, "L": 4, "M": 2, "N": 6, "O": 8, "P": 2, "Q": 1, "R": 6, "S": 4, "T": 6, "U": 4, "V": 2, "W": 2, "X": 1, "Y": 2, "Z": 1, "*": 2}

function randomInteger(below) {
	return Math.floor(Math.random() * below);
}

function forEachIn(object, action) {
  for (var property in object) {
    if (object.hasOwnProperty(property))
      action(property, object[property]);
  };
}

// Takes word as dictionary object
function calculateWordScore(word) {
	score = 0;
	forEachIn(word, function(letter, count) {
		score += LETTER_VALUES[letter] * Number(count);
	});
	return Number(score);
}

function wordToString(word) {
	var stringWord = "";
	forEachIn(word, function(letter, count) {
		for (var i = 0; i < count; i++) {
			stringWord += letter;
		};
	});
	return stringWord;
}

function stringToWord(word) {
	var wordDict = Dictionary.create();
	for (var i = 0; i < word.length; i++) {
		if (wordDict.contains(word[i]) == false) 
			wordDict.store(word[i], 1);
		else
			wordDict.store(word[i], wordDict.lookup(word[i])+1);
	}
	return wordDict.values;
}

function clone(object) {
  function OneShotConstructor(){}
  OneShotConstructor.prototype = object;
  return new OneShotConstructor();
}

Object.prototype.create = function() {
  var object = clone(this);
  if (typeof object.construct == "function")
    object.construct.apply(object, arguments);
  return object;
};

Object.prototype.extend = function(properties) {
  var result = clone(this);
  forEachIn(properties, function(name, value) {
    result[name] = value;
  });
  return result;
};

function setNodeAttribute(node, attribute, value) {
  if (attribute == "class")
    node.className = value;
  else if (attribute == "checked")
    node.defaultChecked = value;
  else if (attribute == "for")
    node.htmlFor = value;
  else if (attribute == "style")
    node.style.cssText = value;
  else
    node.setAttribute(attribute, value);
};

function removeElement(node) {
  if (node.parentNode)
    node.parentNode.removeChild(node);
};

function dom(name, attributes) {
  var node = document.createElement(name);
  if (attributes) {
    forEachIn(attributes, function(name, value) {
      setNodeAttribute(node, name, value);
    });
  }
  for (var i = 2; i < arguments.length; i++) {
    var child = arguments[i];
    if (typeof child == "string")
      child = document.createTextNode(child);
    node.appendChild(child);
  }
  return node;
};

function registerEventHandler(node, event, handler) {
  if (typeof node.addEventListener == "function")
    node.addEventListener(event, handler, false);
  else
    node.attachEvent("on" + event, handler);
};

function addHandler(node, type, handler) {
  function wrapHandler(event) {
    handler(window.event);
  }
  registerEventHandler(node, type, wrapHandler);
  return {node: node, type: type, handler: wrapHandler};
}

function removeHandler(object) {
  unregisterEventHandler(object.node, object.type, object.handler);
}

function method(object, name) {
  return function() {
    return object[name].apply(object, arguments);
  };
}

var Dictionary = {
	construct: function(object) {
		this.values = object || {};
	},
	store: function(letter, value) {
		this.values[letter] = value;
	},
	lookup: function(letter) {
		return this.values[letter];
	},
	contains: function(letter) {
		return Object.prototype.hasOwnProperty.call(this.values, letter) &&
		Object.prototype.propertyIsEnumerable.call(this.values, letter);
	},
	each: function(action) {
		forEachIn(this.values, action);
	},
	remove: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	createArray: function() {
		var lettersArray = [];
		this.each(function(letter, value) {
			for (var i = 0; i < value; i++) {
				lettersArray.push(letter);
				}
			});
		return lettersArray;
	}
};

var Bag = Dictionary.extend({
	construct: function() {
		this.values = LETTER_COUNTS;
	},
	selectRandomLetter: function() {
		lettersArray = this.createArray();
		return lettersArray[randomInteger(lettersArray.length)];
	},
	count: function() {
		lettersArray = this.createArray();
		return lettersArray.length;
	}
});

var Hand = Dictionary.extend({
	construct: function(bag, startValues) {
		this.bag = bag;
		this.values = startValues || {};
		if (startValues == null)
			this.initialHand();
		copy = this.createArray();
		var tbody = dom("TBODY");
		var tableRow = dom("TR");
		tbody.appendChild(tableRow);
		for (var i = 0; i < HAND_SIZE; i++) {
			if (copy[i]) {
				if (copy[i] == " ")
					var tableCell = dom("TD", {"id": String(i)}, "*");
				else
					var tableCell = dom("TD", {"id": String(i)}, copy[i]);
				}
			tableRow.appendChild(tableCell);
		};
		
		this.table = dom("TABLE", {"id": "hand", "border": "1"}, tbody);
	},
	isValidHand: function(word) {
		copy = this.createArray();
		for (var i = 0; i < word.length; i++) {
			if (copy.indexOf(word[i]) == -1)
				return false;
			else
				delete copy[copy.indexOf(word[i])];
		};
		return true;
	},
	grabLetter: function() {
		newLetter = this.bag.selectRandomLetter();
		this.addLetter(newLetter);
		this.bag.remove(newLetter);
		return newLetter;
	},
	initialHand: function() {
		for (var i = 0; i < HAND_SIZE; i++) {
			this.grabLetter(this.bag);
		};
	},
	removeLetter: function(letter) {
		if (this.contains(letter) == false || (this.lookup(letter) < 0))
			throw "Hand doesn't contain letter";
		else
			this.store(letter, this.lookup(letter)-1);
	},
	addLetter: function(letter) {
		if (this.contains(letter) == false) 
			this.store(letter, 1);
		else
			this.store(letter, this.lookup(letter)+1);
	},
	clear: function() {
		this.values = {};
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
});

/*
var Square = {
	construct: function(x, y) {
		this.x = x;
		this.y = y;
		this.letter = "  ";
		this.lock = false;
	},
	isEmpty: function() {
		return this.letter == "  ";
	},
	setLock: function() {
		this.lock = true;
	},
	getLock: function() {
		return this.lock;
	},
	setLetter: function(letter) {
		this.letter = letter;
	},
	getLetter: function() {
		return this.letter;
	}
};	
*/
	
var Board = {
	construct: function(width, height) {
		this.width = width;
		this.height = height;
		var lock = true;

		this.board = [];
		var tbody = dom("TBODY");
		for (var y = 0; y < this.height; y++) {
			var row = [];
			var tableRow = dom("TR");
			for (var x = 0; x < this.width; x++) {
				var tableSquare = dom("TD", {"id": String(x) + String(y), "class": "empty"}, "  ");
				tableRow.appendChild(tableSquare);
				// row.push(Square.create(x, y));
				row.push([lock, null]);
			}
			tbody.appendChild(tableRow);
			this.board.push(row);
		}
		
		this.table = dom("TABLE", {"id": "board", "border": "1"}, tbody);
	},
	valueAt: function(x, y) {
		try {
			return this.board[y][x][1];
		}
		catch (error) {
			return null;
		}
	},
	isEmpty: function(x, y) {
		return this.valueAt(x, y) == null;
	},
	placeLetter: function(x, y, letter) {
		if (this.isEmpty(x, y)) {
			this.board[y][x][1] = letter;
			this.setLock(x, y, false);
		}
	},
	removeLetter: function(x, y) {
		this.board[y][x][1] = null;
	},
	// Sets lock to boolean 'value'. 'true' if one can't move the space, such as in an empty space or a letter that has already been played. 'false' if one can move the letter such as in rearranging letters for a play
	setLock: function(x, y, value) {
		this.board[y][x][0] = value;
	},
	getLock: function(x, y) {
		return this.board[y][x][0];
	},
	rowOrColumn: function(play) {
		if (play.length < 2)
			return "single";
		if (play[0][0] == play[1][0])
			return "column";
		else if (play[0][1] == play[1][1])
			return "row";
		else
			return false;
	},
	// Takes array of arrays in the form [x, y]. Are they all in a single row or column? Are all the values adjacent to each other? If so, returns true. Requires there are at least two tiles played.
	isInline: function(play) {
		var xValue = play[0][0],
			yValue = play[0][1],
			rowOrColumn = this.rowOrColumn(play);
		if (rowOrColumn) {
			for (var i = 1; i < play.length; i++) {
				if (rowOrColumn == "column") {
					// Checks if value is in the same row and if the y value is adjacent to the previous y value
					if ((play[i][0] != xValue) || (play[i][1] != (play[i-1][1] + 1)))
						return false;
				}
				else if (rowOrColumn == "row") {
					if ((play[i][1] != yValue) || (play[i][0] != (play[i-1][0] + 1)))
						return false;
				}
				else if (rowOrColumn == "single")
					return true;
			};
		}
		else
			return false;
		return true;
	},
	// Scans board with play from findPlay plus the letters that are already on the board that the player is playing from
	// Checks if letter is placed on board after the row of tiles that are represented by play. If so, places letter in play array. Runs itself again to check.
	// TODO: Make findPlayPlus start with the first tile from findPlay. Then scan the board from that first tile to determine the next in line. If there's a next one, add it to playPlus. If not, break. These tiles for which it scans can be locked or unlocked. Create 2 different array possibilities. One for column, one for row. See if either passes. No need to determine whether it's a column or row first. Just run the recursion and record the results. If none, one, or both the row and column pass isInline, confirm the word(s) and give the score.
	// TODO: Delete rowOrColumn
	// TODO: Make findPlayPlus pick up both locked squares and other tiles in Play
	findPlayPlus: function(play) {
		var first = play[0],
			row = [first],
			column = [first];
		var rowAfter = this.rowAfterPlay(first);
		while (rowAfter) {
			row.push(rowAfter);
			rowAfter = this.rowAfterPlay(row);
		}
		var rowBefore = this.rowBeforePlay(first);
		while (rowBefore) {
			row.unshift(rowBefore)
			rowBefore = this.rowBeforePlay(row);
		}
		/*
		var columnAfter = this.columnAfterPlay(first);
		while (columnAfter) {
			column.push(columnAfter);
			columnAfter = this.columnAfterPlay(column);
		}
		var columnBefore = this.columnBeforePlay(first);
		while (columnBefore) {
			column.unshift(columnBefore);
			columnBefore = this.columnBeforePlay(column);
		}
		*/
		if (row.length > 1) {
			console.log("row");
			return row;
		}
		else if (column.length > 1) {
			console.log("column");
			return column;
		}
		else
			return play;
	},
	/*
	findPlayPlus: function(play) {
		var rowOrColumn = this.rowOrColumn(play),
			playPlus = play;
		if (rowOrColumn == "row") {
			var rowAfter = this.rowAfterPlay(play);
			while (rowAfter) {
				playPlus.push(rowAfter);
				rowAfter = this.rowAfterPlay(playPlus);
			}
			var rowBefore = this.rowBeforePlay(play);
			while (rowBefore) {
				playPlus.unshift(rowBefore)
				rowBefore = this.rowBeforePlay(playPlus);
			}
		}
		if (rowOrColumn == "column") {
			var columnAfter = this.columnAfterPlay(play);
			while (columnAfter) {
				playPlus.push(columnAfter);
				columnAfter = this.columnAfterPlay(playPlus);
			}
			var columnBefore = this.columnBeforePlay(play);
			while (columnBefore) {
				playPlus.unshift(columnBefore);
				columnBefore = this.columnBeforePlay(playPlus);
			}
		}
		return playPlus;
	},
	*/
	// TODO: How to pass function with arguments to object when we don't know function's name?
	playPlusHandler: function(fn) {
		var fn = this[fn](play);
		while (fn) {
			playPlus.push(fn);
			fn = this[fn](play);
		}
	},
	rowAfterPlay: function(play) {
		var lastInRow = play[play.length-1];
		if (this.valueAt(lastInRow[0]+1, lastInRow[1]))
			return [lastInRow[0]+1, lastInRow[1]];
		else
			return null;
	},
	rowBeforePlay: function(play) {
		var firstInRow = play[0];
		if (this.valueAt(firstInRow[0]-1, firstInRow[1]))
			return [firstInRow[0]-1, firstInRow[1]];
		else
			return null;
	},
	columnAfterPlay: function(play) {
		var lastInColumn = play[play.length-1];
		if (this.valueAt(lastInColumn[0], lastInColumn[1]+1))
			return [lastInColumn[0], lastInColumn[1]+1];
		else
			return null;
	},
	columnBeforePlay: function(play) {
		var firstInColumn = play[0];
		if (this.valueAt(firstInColumn[0], firstInColumn[1]-1))
			return [firstInColumn[0], firstInColumn[1]-1];
		else
			return null;
	},
	// Scans board for letters with a lock of false to determine the play
	findPlay: function() {
		play = [];
		for (var y = 0; y < this.height; y++) {
			for (var x = 0; x < this.width; x++) {	
				if (this.board[y][x][0] == false)
					play.push([x, y]);
			}
		}
		return play;
	},	
	// Sets play as permanent; i.e., 'locks' tiles on board
	setPlay: function(play) {
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			this.board[y][x][0] = true;
		}
	},
	// Takes array of arrays in the form [x, y]. Return string from letters placed on board.
	boardToWord: function(play) {
		word = "";
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			word += this.board[y][x][1];
		}
		return word;
	},
	each: function(func) {
		for (var i = 0; i < this.height; i++) {
			for (var j = 0; j < this.width; j++) {
				var lock = this.board[i][j][0];
				func(lock, this.valueAt(j, i));
			}
		}
	},
	placeToPage: function(where) {
		where.appendChild(this.table);
	},
	removeFromPage: function(where) {
		removeElement(this.table);
	}
};

var Game = {
	construct: function(place) {
		this.bag = null;
		this.hand = null;
		this.board = null;
		this.place = place;
		this.score = 0;
		
		this.initial();
		
		$('<button id="newGame">New game</button>').appendTo(this.place);
		$('#newGame').on('click', function() {
			location.reload();
			});
		$('<button id="newHand">New hand</button>').appendTo(this.place);
		$('#newHand').on('click', method(this, 'newHand'));
		
		$('<button id="submitWord">Submit word</button>').appendTo(this.place);
		$('#submitWord').on('click', method(this, 'submitWord'));

		$('<div id="score">&nbsp;</div>').appendTo(this.place);
		$('<div id="messages">&nbsp;</div>').appendTo(this.place);
		
		var letterEvent = null,
			self = this;
		
		//children().children().children() means #hand table -> tbody -> tr -> td
		//Hand click handlers
		$('#hand').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				// Placing a letter back in hand
				if (letterEvent && $this.text() == "  ") {
					$this.text(letterEvent[0]);
					$this.removeClass("empty").removeClass("empty-hand");
					
					$id = $('#' + letterEvent[1])
					square = $id.attr('id');
					$id.removeClass("selected-letter")
						.text("  ");
					// Determining whether letter was grabbed from board
					if (letterEvent[1].length == 2) {
						self.hand.addLetter(letterEvent[0]);
						self.board.removeLetter(square[0], square[1]);
						self.board.setLock(square[0], square[1], true);
						$id.addClass('empty')
							.removeClass('placed-letter');
					}
					else
						$id.addClass('empty-hand');
					letterEvent = null;
				}
				// Grabbing letter from hand
				else if (!letterEvent && $this.text() != "  ") {
					$this.addClass("selected-letter");
					letterEvent = [$this.text(), $this.attr("id")];
				}
				else if (letterEvent && $this.text() == letterEvent[0]) {
					self.deselectHandler(letterEvent);
					letterEvent = null;
				}
			});
		});
		
		//children().children().children() means #board table -> tbody -> tr -> td
		//Board click handlers
		$('#board').children().children().children().each(function() {
			var $this = $(this);
			$this.on('click', function() {
				var square = $this.attr("id");
				// Place letter on board
				if ((letterEvent) && (self.board.isEmpty(square[0], square[1]))) {
					self.placeLetterFromHand(square[0], square[1], letterEvent[0]);
					$('#' + String(square[0]) + String(square[1])).text(letterEvent[0])
																	.removeClass('empty')
																	.addClass('placed-letter');
					
					$id = $('#' + letterEvent[1])
					square = $id.attr('id');
					$id.removeClass("selected-letter");
					if (letterEvent[1].length < 2) {
						self.hand.removeLetter($id.text());
						$id.addClass('empty-hand');
					}
					else {
						self.board.removeLetter(square[0], square[1]);
						self.board.setLock(square[0], square[1], true);
						$id.addClass('empty')
							.removeClass('placed-letter');
					}
					$id.text("  ");
					letterEvent = null;
				}
				// Grab letter from board
				else if ((!letterEvent) && (self.board.getLock(square[0], square[1]) == false)) {
					letterEvent = [$this.text(), $this.attr("id")];
					$this.addClass("selected-letter");
				}
				else if (letterEvent && $this.text() == letterEvent[0]) {
					self.deselectHandler(letterEvent);
					letterEvent = null;
				}				
			});
		});
	},
	deselectHandler: function(letterEvent) {
		var $id = $('#' + letterEvent[1]);
		$id.text(letterEvent[0]);
		$id.removeClass("selected-letter");
	},
	initial: function() {
		if (this.board && this.hand) {
			this.board.removeFromPage(this.place);
			this.hand.removeFromPage(this.place);
		}
		this.score = 0;
		this.first = true;
		this.board = Board.create(BOARD_WIDTH, BOARD_HEIGHT);
		this.board.placeToPage(this.place);
		this.bag = Bag.create();
		this.hand = Hand.create(this.bag, null);
		this.hand.placeToPage(this.place);
	},
	newHand: function() {
		if (this.board && this.hand && (this.bag.count() >= HAND_SIZE)) {
		/*
			this.hand.clear();
			this.hand.removeFromPage(this.place);
			this.hand = Hand.create(this.bag, null);
			this.hand.placeToPage(this.place);
		*/
		}
		else
			$('#messages').text("Bag out of letters");
	},
	submitWord: function() {
		var play = this.board.findPlay(),
			count = play.length,
			playPlus = this.board.findPlayPlus(play),
			check = true;
		console.log(playPlus);
		// Check if play includes letter placed on board
		if (playPlus.length == count && this.first == false) {
				check = false;
			}
		// TODO: Sort playPlus before checking isInline
		// TODO: Re-write sequence submitWord to accept a possible 2 words per play
		if (this.board.isInline(playPlus) && check) {
			var word = this.board.boardToWord(playPlus),
				wordDict = stringToWord(word),
				score = calculateWordScore(wordDict);
			this.replenishHand(count);
			this.board.setPlay(play);
			this.setPlayStyle(play);
			$('#messages').text("Valid word: " + word)
							.removeClass('error');
			this.updateScore(score);
			this.first = false;
		}
		else {
			$('#messages').text("Invalid word")
							.addClass('error');
		}
	},
	replenishHand: function(count) {
		for (var i = 0; i < count; i++) {
			var letter = this.hand.grabLetter();
			
			var $space = $('.empty-hand')
										.first()
										.text(letter)
										.removeClass('empty-hand');
		}
	},
	// Removes styling for letters placed on board during play
	setPlayStyle: function(play) {
		for (var i = 0; i < play.length; i++) {
			var x = play[i][0];
			var y = play[i][1];
			$('#' + x + y).removeClass('placed-letter');
		}
	},
	placeLetterFromHand: function(x, y, letter) {
		this.board.placeLetter(x, y, letter);
	},
	updateScore: function(newPoints) {
		this.score += newPoints;
		$('#score').text("Word score: " + newPoints + ", Total score: " + this.score);
	}
};

function isInlineTests() {
	var testBoard = Board.create(5, 5);
	return (testBoard.isInline([[1,2], [1,3], [1, 4]]) == true) &&
			(testBoard.isInline([[0, 2], [1, 2], [2, 2]]) == true) &&
			(testBoard.isInline([[0, 3], [0, 4], [0, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 2]]) == false) &&
			(testBoard.isInline([[0, 1], [0, 2], [0, 3], [0, 0]]) == false) &&
			(testBoard.isInline([[0, 0], [1, 1]]) == false) &&
			(testBoard.isInline([[0, 1], [1, 0]]) == false);
}
function rowOrColumnTests() {
	var testBoard = Board.create(5, 5);
	return testBoard.rowOrColumn([[0, 2], [1, 2], [2, 2]]) == "row" &&
			(testBoard.rowOrColumn([[1, 2], [1, 3], [1, 4]]) == "column") &&
			(testBoard.rowOrColumn([[0, 3], [0, 4], [0, 1]]) == "column") &&
			(testBoard.rowOrColumn([[0, 1], [1, 2]]) == false) &&
			(testBoard.rowOrColumn([[0, 1], [1, 0]]) == false) &&
			(testBoard.rowOrColumn([[0, 1]]) == "single");
}
function isValidHandTests(testBag) {
	var testHand = Hand.create(testBag, {"B": 1, "A": 2, "Y": 1});
	return testHand.isValidHand("BABY") == false &&
		testHand.isValidHand("BAY") ==  true &&
		testHand.isValidHand("BY") == true &&
		testHand.isValidHand("XBY") == false &&
		testHand.isValidHand("BAAY") == true;
}
function calculateWordScoreTests() {
	return calculateWordScore({"B": 1, "A": 1, "G": 1}) == 6 &&
		calculateWordScore({"A": 1, "B": 1, "C": 2}) == 10 &&
		calculateWordScore({"F": 1, "G": 1, "H": 1}) == 10 &&
		calculateWordScore({"X": 4}) == 32;
}

console.log("calculateWordScore tests: " + calculateWordScoreTests());
console.log("rowOrColumn tests: " + rowOrColumnTests());
console.log("isInline tests: " + isInlineTests());
var testBag = Bag.create();
console.log("isValidHand tests: " + isValidHandTests(testBag));

var scrabble = Game.create(document.body);

});
</script>
</body>
</html>